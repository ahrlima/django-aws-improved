import csv
import json
import tempfile
from pathlib import Path

from django.core.management import call_command
from django.test import Client, SimpleTestCase, TestCase

from .models import SalaryObservation, SalaryRoleAggregate
from .salary_data import summarize_salaries, role_insights


class BaseClientTest(TestCase):
    @classmethod
    def setUpTestData(cls):
        super().setUpTestData()
        call_command("load_salary_dataset")
        cls.assert_aggregates_exist()

    @classmethod
    def assert_aggregates_exist(cls):
        if not SalaryRoleAggregate.objects.exists():
            raise AssertionError("Role aggregates were not generated by load_salary_dataset")

    def setUp(self):
        super().setUp()
        self.client = Client()


class HealthCheckTests(BaseClientTest):
    def test_healthz_returns_ok(self):
        response = self.client.get("/healthz")
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content.decode(), "OK")


class SalarySummaryTests(BaseClientTest):
    def test_requires_role_parameter(self):
        response = self.client.get("/api/salaries/")
        self.assertEqual(response.status_code, 400)
        self.assertIn("error", response.json())

    def test_returns_summary_for_role(self):
        response = self.client.get("/api/salaries/", {"role": "software_engineer"})
        self.assertEqual(response.status_code, 200)
        data = response.json()
        self.assertEqual(data["total_observations"], 4)
        self.assertEqual(len(data["currencies"]), 1)
        usd_summary = data["currencies"][0]
        self.assertEqual(usd_summary["currency"], "BRL")
        self.assertEqual(usd_summary["observations"], 4)
        self.assertAlmostEqual(usd_summary["base_salary"]["min"], 78000.0)
        self.assertAlmostEqual(usd_summary["total_compensation"]["max"], 255000.0)
        levels = {item["level"] for item in data["levels"]}
        self.assertIn("senior", levels)
        self.assertIn("junior", levels)
        states = {item["state"] for item in data["states"]}
        self.assertIn("SP", states)
        work_models = {item["work_model"] for item in data["work_models"]}
        self.assertIn("remoto", work_models)

    def test_filters_by_country(self):
        response = self.client.get(
            "/api/salaries/",
            {
                "role": "data_scientist",
                "country": "Brazil",
            },
        )
        self.assertEqual(response.status_code, 200)
        data = response.json()
        self.assertEqual(data["total_observations"], 2)
        currencies = {item["currency"] for item in data["currencies"]}
        self.assertEqual(currencies, {"BRL"})
        work_models = {item["work_model"] for item in data["work_models"]}
        self.assertEqual(work_models, {"hibrido", "remoto"})

    def test_filters_by_state_and_work_model(self):
        response = self.client.get(
            "/api/salaries/",
            {
                "role": "software_engineer",
                "state": "sp",
                "work_model": "hibrido",
            },
        )
        self.assertEqual(response.status_code, 200)
        data = response.json()
        self.assertEqual(data["total_observations"], 1)
        self.assertEqual(data["states"][0]["state"], "SP")
        self.assertEqual(data["work_models"][0]["work_model"], "hibrido")


class SalaryComparisonTests(BaseClientTest):
    def test_requires_roles_parameter(self):
        response = self.client.get("/api/salaries/comparison/")
        self.assertEqual(response.status_code, 400)
        self.assertIn("error", response.json())

    def test_accepts_comma_separated_roles(self):
        response = self.client.get(
            "/api/salaries/comparison/",
            {
                "roles": "software_engineer,cloud_engineer",
            },
        )
        self.assertEqual(response.status_code, 200)
        data = response.json()
        roles = {role["role"] for role in data["roles"]}
        self.assertEqual(roles, {"software_engineer", "cloud_engineer"})

    def test_filters_are_applied_to_each_role(self):
        response = self.client.get(
            "/api/salaries/comparison/",
            {
                "roles": "analista_de_sistemas,product_owner",
                "state": "mg",
            },
        )
        self.assertEqual(response.status_code, 200)
        data = response.json()
        self.assertEqual(len(data["roles"]), 2)
        brazil_counts = {role["role"]: role["total_observations"] for role in data["roles"]}
        self.assertEqual(brazil_counts["analista_de_sistemas"], 1)
        self.assertEqual(brazil_counts["product_owner"], 0)


class BuildSalaryDatasetCommandTests(SimpleTestCase):
    def setUp(self):
        super().setUp()
        self.tmpdir = tempfile.TemporaryDirectory()
        self.output_path = Path(self.tmpdir.name) / "canonical.csv"

    def tearDown(self):
        self.tmpdir.cleanup()
        super().tearDown()

    def test_generates_canonical_dataset(self):
        raw_path = Path(self.tmpdir.name) / "raw_sample.csv"
        with raw_path.open("w", newline="", encoding="utf-8") as handle:
            writer = csv.DictWriter(
                handle,
                fieldnames=[
                    "source",
                    "job_title",
                    "experience_level",
                    "city",
                    "state",
                    "country",
                    "salary_currency",
                    "remote_type",
                    "salary_min",
                    "salary_max",
                    "salary_total",
                ],
            )
            writer.writeheader()
            writer.writerow(
                {
                    "source": "levels_fyi",
                    "job_title": "Software Engineer",
                    "experience_level": "Senior",
                    "city": "São Paulo",
                    "state": "SP",
                    "country": "Brazil",
                    "salary_currency": "BRL",
                    "remote_type": "remote",
                    "salary_min": "150000",
                    "salary_max": "190000",
                    "salary_total": "205000",
                }
            )

        call_command(
            "build_salary_dataset",
            input_dir=self.tmpdir.name,
            output=str(self.output_path),
        )

        self.assertTrue(self.output_path.exists())
        with self.output_path.open(newline="", encoding="utf-8") as handle:
            rows = list(csv.DictReader(handle))

        self.assertEqual(len(rows), 1)
        row = rows[0]
        self.assertEqual(row["role"], "software_engineer")
        self.assertEqual(row["state"], "SP")
        self.assertEqual(row["work_model"], "remoto")


class FetchSalarySourcesCommandTests(SimpleTestCase):
    def setUp(self):
        super().setUp()
        self.tmpdir = tempfile.TemporaryDirectory()
        self.source_dir = Path(self.tmpdir.name)
        self.raw_dir = self.source_dir / "raw"
        self.raw_dir.mkdir()

        self.sample_csv = self.source_dir / "sample.csv"
        self.sample_csv.write_text("col\nvalue\n", encoding="utf-8")

        config = {
            "sources": [
                {
                    "name": "sample",
                    "url": self.sample_csv.resolve().as_uri(),
                    "dest": "sample_downloaded.csv",
                }
            ]
        }
        self.config_path = self.source_dir / "config.json"
        self.config_path.write_text(json.dumps(config), encoding="utf-8")

    def tearDown(self):
        self.tmpdir.cleanup()
        super().tearDown()

    def test_downloads_file_from_config(self):
        output_dir = self.source_dir / "output"
        call_command(
            "fetch_salary_sources",
            config=str(self.config_path),
            output_dir=str(output_dir),
        )

        downloaded_file = output_dir / "sample_downloaded.csv"
        self.assertTrue(downloaded_file.exists())
        self.assertEqual(downloaded_file.read_text(encoding="utf-8"), "col\nvalue\n")


class LoadSalaryDatasetCommandTests(TestCase):
    def setUp(self):
        super().setUp()
        self.tmpdir = tempfile.TemporaryDirectory()

        self.dataset_path = Path(self.tmpdir.name) / "dataset.csv"
        with self.dataset_path.open("w", newline="", encoding="utf-8") as handle:
            fieldnames = [
                "source",
                "role",
                "level",
                "location",
                "state",
                "country",
                "currency",
                "work_model",
                "base_salary_min",
                "base_salary_max",
                "total_compensation",
            ]
            writer = csv.DictWriter(handle, fieldnames=fieldnames)
            writer.writeheader()
            writer.writerow(
                {
                    "source": "levels_fyi",
                    "role": "software_engineer",
                    "level": "senior",
                    "location": "São Paulo",
                    "state": "SP",
                    "country": "Brazil",
                    "currency": "BRL",
                    "work_model": "remoto",
                    "base_salary_min": "150000",
                    "base_salary_max": "190000",
                    "total_compensation": "205000",
                }
            )

    def tearDown(self):
        self.tmpdir.cleanup()
        super().tearDown()

    def test_loads_dataset_into_database(self):
        call_command("load_salary_dataset", input=str(self.dataset_path))
        self.assertEqual(SalaryObservation.objects.count(), 1)
        observation = SalaryObservation.objects.first()
        self.assertEqual(observation.role, "software_engineer")
        self.assertEqual(observation.currency, "BRL")
        aggregates = SalaryRoleAggregate.objects.filter(role="software_engineer")
        self.assertTrue(aggregates.exists())


class SalaryInsightsTests(BaseClientTest):
    def test_requires_role_parameter(self):
        response = self.client.get("/api/salaries/insights/")
        self.assertEqual(response.status_code, 400)
        self.assertIn("error", response.json())

    def test_returns_percentiles_and_top_groups(self):
        response = self.client.get(
            "/api/salaries/insights/",
            {
                "role": "software_engineer",
            },
        )
        self.assertEqual(response.status_code, 200)
        data = response.json()
        self.assertEqual(data["total_observations"], 4)
        percentiles = data["percentiles"]
        self.assertAlmostEqual(percentiles["p25"], 138750.0)
        self.assertAlmostEqual(percentiles["median"], 177500.0)
        self.assertAlmostEqual(percentiles["p75"], 217500.0)
        self.assertGreaterEqual(len(data["top_states"]), 1)
        self.assertEqual(data["top_states"][0]["state"], "RS")

    def test_filters_apply_to_insights(self):
        response = self.client.get(
            "/api/salaries/insights/",
            {
                "role": "software_engineer",
                "state": "sp",
            },
        )
        self.assertEqual(response.status_code, 200)
        data = response.json()
        self.assertEqual(data["total_observations"], 2)
        self.assertEqual(len(data["top_states"]), 1)
        self.assertEqual(data["top_states"][0]["state"], "SP")


class DashboardViewTests(BaseClientTest):
    def test_dashboard_renders(self):
        response = self.client.get("/dashboard/")
        self.assertEqual(response.status_code, 200)
        self.assertIn("Tech Salary Insights", response.content.decode())

    def test_root_path_renders_dashboard(self):
        response = self.client.get("/")
        self.assertEqual(response.status_code, 200)
        self.assertIn("Tech Salary Insights", response.content.decode())


class SalaryAggregateCacheTests(TestCase):
    @classmethod
    def setUpTestData(cls):
        super().setUpTestData()
        call_command("load_salary_dataset")

    def test_summary_matches_cached_payload(self):
        aggregate = SalaryRoleAggregate.objects.get(role="software_engineer")
        summary = summarize_salaries("software_engineer")
        self.assertEqual(summary, aggregate.summary)

    def test_insights_match_cached_payload(self):
        aggregate = SalaryRoleAggregate.objects.get(role="software_engineer")
        insights = role_insights("software_engineer")
        self.assertEqual(insights, aggregate.insights)

    def test_recompute_without_cache(self):
        SalaryRoleAggregate.objects.filter(role="software_engineer").delete()
        summary = summarize_salaries("software_engineer", use_cache=False)
        self.assertEqual(summary["total_observations"], 4)
        # rebuild caches for isolation
        call_command("load_salary_dataset")


class ExportDashboardCommandTests(SimpleTestCase):
    def setUp(self):
        super().setUp()
        self.tmpdir = tempfile.TemporaryDirectory()

    def tearDown(self):
        self.tmpdir.cleanup()
        super().tearDown()

    def test_exports_dashboard_html(self):
        call_command(
            "export_dashboard",
            output_dir=self.tmpdir.name,
            filename="dashboard.html",
        )
        path = Path(self.tmpdir.name) / "dashboard.html"
        self.assertTrue(path.exists())
        content = path.read_text(encoding="utf-8")
        self.assertIn("Tech Salary Insights", content)
