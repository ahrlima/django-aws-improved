import csv
from datetime import datetime
from decimal import Decimal, InvalidOperation
from pathlib import Path
from typing import Iterable, List, Optional

from django.conf import settings
from django.core.management.base import BaseCommand, CommandError
from django.db import transaction

from ...models import SalaryObservation, SalaryRoleAggregate
from ...salary_data import refresh_all_role_aggregates

COLUMN_NAMES = [
    "source",
    "role",
    "level",
    "location",
    "state",
    "country",
    "currency",
    "work_model",
    "base_salary_min",
    "base_salary_max",
    "total_compensation",
]


def _to_decimal(value: str) -> Decimal:
    try:
        return Decimal(value)
    except (InvalidOperation, TypeError):
        raise ValueError(f"Unable to parse decimal value '{value}'")


def _parse_date(value: Optional[str]) -> Optional[datetime.date]:
    if not value:
        return None
    for fmt in ("%Y-%m-%d", "%d/%m/%Y"):
        try:
            return datetime.strptime(value, fmt).date()
        except ValueError:
            continue
    raise ValueError(f"Unable to parse observed_at date '{value}'")


class Command(BaseCommand):
    help = (
        "Load salary observations from the canonical CSV into the database. "
        "By default it replaces existing rows."
    )

    def add_arguments(self, parser):
        parser.add_argument(
            "--input",
            type=str,
            default=None,
            help="Path to the canonical CSV generated by build_salary_dataset.",
        )
        parser.add_argument(
            "--append",
            action="store_true",
            help="Append to existing data instead of replacing it.",
        )

    def handle(self, *args, **options):
        if options["input"]:
            input_path = Path(options["input"])
        else:
            input_path = Path(settings.BASE_DIR) / "data" / "tech_salaries_sample.csv"
        if not input_path.exists():
            raise CommandError(f"Input file {input_path} does not exist.")

        rows = list(self._read_rows(input_path))
        if not rows:
            self.stdout.write(self.style.WARNING("No rows found in input CSV."))
            return

        with transaction.atomic():
            if not options["append"]:
                SalaryObservation.objects.all().delete()
                SalaryRoleAggregate.objects.all().delete()
            SalaryObservation.objects.bulk_create(rows, ignore_conflicts=True)
            refreshed = refresh_all_role_aggregates()

        action = "Appended" if options["append"] else "Loaded"
        self.stdout.write(self.style.SUCCESS(f"{action} {len(rows)} salary observations."))
        self.stdout.write(self.style.SUCCESS(f"Refreshed aggregates for {refreshed} role(s)."))

    def _read_rows(self, path: Path) -> Iterable[SalaryObservation]:
        with path.open(newline="", encoding="utf-8") as handle:
            reader = csv.DictReader(handle)
            missing = [column for column in COLUMN_NAMES if column not in reader.fieldnames]
            if missing:
                raise CommandError(
                    f"Input CSV is missing required columns: {', '.join(missing)}"
                )

            for index, row in enumerate(reader, start=1):
                try:
                    observed_at = _parse_date(row.get("observed_at"))
                    yield SalaryObservation(
                        source=row["source"].strip(),
                        role=row["role"].strip(),
                        level=row["level"].strip(),
                        location=row["location"].strip(),
                        state=row["state"].strip(),
                        country=row["country"].strip(),
                        currency=row["currency"].strip(),
                        work_model=row["work_model"].strip(),
                        base_salary_min=_to_decimal(row["base_salary_min"]),
                        base_salary_max=_to_decimal(row["base_salary_max"]),
                        total_compensation=_to_decimal(row["total_compensation"]),
                        observed_at=observed_at,
                    )
                except (KeyError, ValueError) as exc:
                    raise CommandError(f"Row {index}: {exc}") from exc
